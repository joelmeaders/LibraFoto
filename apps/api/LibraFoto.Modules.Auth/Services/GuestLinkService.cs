using System.Security.Cryptography;
using LibraFoto.Data;
using LibraFoto.Data.Entities;
using LibraFoto.Modules.Auth.Models;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

namespace LibraFoto.Modules.Auth.Services
{
    /// <summary>
    /// Guest link management service implementation using EF Core and SQLite.
    /// </summary>
    public class GuestLinkService : IGuestLinkService
    {
        private readonly LibraFotoDbContext _dbContext;
        private readonly ILogger<GuestLinkService> _logger;

        public GuestLinkService(
            LibraFotoDbContext dbContext,
            ILogger<GuestLinkService> logger)
        {
            _dbContext = dbContext;
            _logger = logger;
        }

        /// <inheritdoc />
        public async Task<GuestLinkDto> CreateGuestLinkAsync(
            CreateGuestLinkRequest request,
            long createdByUserId,
            CancellationToken cancellationToken = default)
        {
            // No longer need to look up user since we have the actual ID now
            var entity = new GuestLink
            {
                // Id is auto-generated by NanoId in the entity
                Name = request.Name,
                CreatedById = createdByUserId,
                DateCreated = DateTime.UtcNow,
                ExpiresAt = request.ExpiresAt,
                MaxUploads = request.MaxUploads,
                CurrentUploads = 0,
                TargetAlbumId = request.TargetAlbumId
            };

            _dbContext.GuestLinks.Add(entity);
            await _dbContext.SaveChangesAsync(cancellationToken);

            // Reload with navigation properties
            await _dbContext.Entry(entity).Reference(e => e.CreatedBy).LoadAsync(cancellationToken);
            if (entity.TargetAlbumId.HasValue)
            {
                await _dbContext.Entry(entity).Reference(e => e.TargetAlbum).LoadAsync(cancellationToken);
            }

            _logger.LogInformation("Created guest link: {LinkId} by user {UserId}", entity.Id, createdByUserId);

            return ToDto(entity);
        }

        /// <inheritdoc />
        public async Task<(IEnumerable<GuestLinkDto> Links, int TotalCount)> GetGuestLinksAsync(
            int page = 1,
            int pageSize = 20,
            bool includeExpired = false,
            CancellationToken cancellationToken = default)
        {
            var query = _dbContext.GuestLinks
                .Include(l => l.CreatedBy)
                .Include(l => l.TargetAlbum)
                .AsQueryable();

            if (!includeExpired)
            {
                query = query.Where(l => l.ExpiresAt == null || l.ExpiresAt > DateTime.UtcNow);
            }

            var totalCount = await query.CountAsync(cancellationToken);

            var links = await query
                .OrderByDescending(l => l.DateCreated)
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync(cancellationToken);

            var dtos = links.Select(ToDto);

            return (dtos, totalCount);
        }

        /// <inheritdoc />
        public async Task<GuestLinkDto?> GetGuestLinkByIdAsync(string id, CancellationToken cancellationToken = default)
        {
            var entity = await _dbContext.GuestLinks
                .Include(l => l.CreatedBy)
                .Include(l => l.TargetAlbum)
                .FirstOrDefaultAsync(l => l.Id == id, cancellationToken);

            return entity != null ? ToDto(entity) : null;
        }

        /// <inheritdoc />
        public async Task<GuestLinkDto?> GetGuestLinkByCodeAsync(string linkCode, CancellationToken cancellationToken = default)
        {
            // Link code is the same as the ID (NanoId)
            return await GetGuestLinkByIdAsync(linkCode, cancellationToken);
        }

        /// <inheritdoc />
        public async Task<GuestLinkValidationResponse> ValidateGuestLinkAsync(string linkCode, CancellationToken cancellationToken = default)
        {
            var entity = await _dbContext.GuestLinks
                .Include(l => l.TargetAlbum)
                .FirstOrDefaultAsync(l => l.Id == linkCode, cancellationToken);

            if (entity == null)
            {
                return new GuestLinkValidationResponse(
                    IsValid: false,
                    Name: null,
                    TargetAlbumName: null,
                    RemainingUploads: null,
                    Message: "Invalid or expired link.");
            }

            // Check expiration
            if (entity.ExpiresAt.HasValue && entity.ExpiresAt.Value < DateTime.UtcNow)
            {
                return new GuestLinkValidationResponse(
                    IsValid: false,
                    Name: entity.Name,
                    TargetAlbumName: entity.TargetAlbum?.Name,
                    RemainingUploads: null,
                    Message: "This link has expired.");
            }

            // Check upload limit
            if (entity.MaxUploads.HasValue && entity.CurrentUploads >= entity.MaxUploads.Value)
            {
                return new GuestLinkValidationResponse(
                    IsValid: false,
                    Name: entity.Name,
                    TargetAlbumName: entity.TargetAlbum?.Name,
                    RemainingUploads: 0,
                    Message: "This link has reached its upload limit.");
            }

            var remaining = entity.MaxUploads.HasValue
                ? entity.MaxUploads.Value - entity.CurrentUploads
                : (int?)null;

            return new GuestLinkValidationResponse(
                IsValid: true,
                Name: entity.Name,
                TargetAlbumName: entity.TargetAlbum?.Name,
                RemainingUploads: remaining,
                Message: null);
        }

        /// <inheritdoc />
        public async Task<bool> RecordUploadAsync(string linkCode, CancellationToken cancellationToken = default)
        {
            var entity = await _dbContext.GuestLinks
                .FirstOrDefaultAsync(l => l.Id == linkCode, cancellationToken);

            if (entity == null)
            {
                return false;
            }

            // Check if still valid
            if (entity.ExpiresAt.HasValue && entity.ExpiresAt.Value < DateTime.UtcNow)
            {
                return false;
            }

            if (entity.MaxUploads.HasValue && entity.CurrentUploads >= entity.MaxUploads.Value)
            {
                return false;
            }

            // Increment upload count
            entity.CurrentUploads++;
            await _dbContext.SaveChangesAsync(cancellationToken);

            _logger.LogInformation("Recorded upload for guest link: {LinkId}. Total: {Count}",
                linkCode, entity.CurrentUploads);

            return true;
        }

        /// <inheritdoc />
        public async Task<bool> DeleteGuestLinkAsync(string id, CancellationToken cancellationToken = default)
        {
            var entity = await _dbContext.GuestLinks
                .FirstOrDefaultAsync(l => l.Id == id, cancellationToken);

            if (entity == null)
            {
                return false;
            }

            _dbContext.GuestLinks.Remove(entity);
            await _dbContext.SaveChangesAsync(cancellationToken);

            _logger.LogInformation("Deleted guest link: {LinkId}", id);
            return true;
        }

        /// <inheritdoc />
        public async Task<IEnumerable<GuestLinkDto>> GetGuestLinksByUserAsync(long userId, CancellationToken cancellationToken = default)
        {
            var links = await _dbContext.GuestLinks
                .Include(l => l.CreatedBy)
                .Include(l => l.TargetAlbum)
                .Where(l => l.CreatedById == userId)
                .OrderByDescending(l => l.DateCreated)
                .ToListAsync(cancellationToken);

            return links.Select(ToDto);
        }

        private static GuestLinkDto ToDto(GuestLink entity)
        {
            var isActive = (entity.ExpiresAt == null || entity.ExpiresAt > DateTime.UtcNow) &&
                           (entity.MaxUploads == null || entity.CurrentUploads < entity.MaxUploads);

            return new GuestLinkDto(
                entity.Id,
                entity.Name,
                entity.DateCreated,
                entity.ExpiresAt,
                entity.MaxUploads,
                entity.CurrentUploads,
                entity.TargetAlbumId,
                entity.TargetAlbum?.Name,
                entity.CreatedById,
                entity.CreatedBy.Email,
                isActive);
        }
    }
}
